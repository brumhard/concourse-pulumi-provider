# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'GroupArgs',
    'JobArgs',
    'ResourceTypeArgs',
    'ResourceArgs',
    'StepArgs',
]

@pulumi.input_type
class GroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 jobs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: A unique name for the group. This should be short and simple as it will be used as the tab name for navigation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jobs: A list of jobs that should appear in this group. A job may appear in multiple groups. Neighbours of jobs in the current group will also appear on the same page in order to give context of the location of the group in the pipeline. You may also use any valid glob to represent several jobs.
        """
        pulumi.set(__self__, "name", name)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A unique name for the group. This should be short and simple as it will be used as the tab name for navigation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of jobs that should appear in this group. A job may appear in multiple groups. Neighbours of jobs in the current group will also appear on the same page in order to give context of the location of the group in the pipeline. You may also use any valid glob to represent several jobs.
        """
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jobs", value)


@pulumi.input_type
class JobArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 plan: pulumi.Input[Sequence[pulumi.Input['StepArgs']]],
                 ensure: Optional[pulumi.Input['StepArgs']] = None,
                 max_in_flight: Optional[pulumi.Input[float]] = None,
                 on_abort: Optional[pulumi.Input['StepArgs']] = None,
                 on_error: Optional[pulumi.Input['StepArgs']] = None,
                 on_failure: Optional[pulumi.Input['StepArgs']] = None,
                 on_success: Optional[pulumi.Input['StepArgs']] = None,
                 public: Optional[pulumi.Input[bool]] = None,
                 serial: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name of the job. This should be short; it will show up in URLs.
        :param pulumi.Input['StepArgs'] ensure: Step to execute regardless of whether the job succeeds, fails, errors, or aborts.
        :param pulumi.Input[float] max_in_flight: If set, specifies a maximum number of builds to run at a time. If serial or serial_groups are set, they take precedence and force this value to be 1.
        :param pulumi.Input['StepArgs'] on_abort: Step to execute when the job aborts.
        :param pulumi.Input['StepArgs'] on_error: Step to execute when the job errors.
        :param pulumi.Input['StepArgs'] on_failure: Step to execute when the job fails.
        :param pulumi.Input['StepArgs'] on_success: Step to execute when the job succeeds.
        :param pulumi.Input[bool] public: Default false. If set to true, the build log of this job will be viewable by unauthenticated users. Unauthenticated users will always be able to see the inputs, outputs, and build status history of a job. This is useful if you would like to expose your pipeline publicly without showing sensitive information in the build log.
        :param pulumi.Input[bool] serial: Default false. If set to true, builds will queue up and execute one-by-one, rather than executing in parallel.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "plan", plan)
        if ensure is not None:
            pulumi.set(__self__, "ensure", ensure)
        if max_in_flight is not None:
            pulumi.set(__self__, "max_in_flight", max_in_flight)
        if on_abort is not None:
            pulumi.set(__self__, "on_abort", on_abort)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the job. This should be short; it will show up in URLs.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def plan(self) -> pulumi.Input[Sequence[pulumi.Input['StepArgs']]]:
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[Sequence[pulumi.Input['StepArgs']]]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def ensure(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute regardless of whether the job succeeds, fails, errors, or aborts.
        """
        return pulumi.get(self, "ensure")

    @ensure.setter
    def ensure(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "ensure", value)

    @property
    @pulumi.getter(name="maxInFlight")
    def max_in_flight(self) -> Optional[pulumi.Input[float]]:
        """
        If set, specifies a maximum number of builds to run at a time. If serial or serial_groups are set, they take precedence and force this value to be 1.
        """
        return pulumi.get(self, "max_in_flight")

    @max_in_flight.setter
    def max_in_flight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_in_flight", value)

    @property
    @pulumi.getter(name="onAbort")
    def on_abort(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute when the job aborts.
        """
        return pulumi.get(self, "on_abort")

    @on_abort.setter
    def on_abort(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "on_abort", value)

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute when the job errors.
        """
        return pulumi.get(self, "on_error")

    @on_error.setter
    def on_error(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "on_error", value)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute when the job fails.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute when the job succeeds.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "on_success", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        Default false. If set to true, the build log of this job will be viewable by unauthenticated users. Unauthenticated users will always be able to see the inputs, outputs, and build status history of a job. This is useful if you would like to expose your pipeline publicly without showing sensitive information in the build log.
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[bool]]:
        """
        Default false. If set to true, builds will queue up and execute one-by-one, rather than executing in parallel.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serial", value)


@pulumi.input_type
class ResourceTypeArgs:
    def __init__(__self__, *,
                 check_every: Optional[pulumi.Input[str]] = None,
                 defaults: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] check_every: Default 1m. The interval on which to check for new versions of the resource. Acceptable interval options are defined by the time.ParseDuration function. If set to never the resource will not be automatically checked. The resource can still be checked manually via the web UI, fly, or webhooks.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] defaults: The default configuration for the resource type. This varies by resource type, and is a black box to Concourse; it is merged with (duplicate fields are overwritten by) resource.source and passed to the resource at runtime.
        :param pulumi.Input[str] name: TThe name of the resource type. This should be short and simple. This name will be referenced by pipeline.resources defined within the same pipeline, and task.image_resources used by tasks running in the pipeline.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] params: Arbitrary config to pass when running the get to fetch the resource type's image.
        :param pulumi.Input[bool] privileged: Default false. If set to true, the resource's containers will be run with full capabilities, as determined by the worker backend the task runs on.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] source: The configuration for the resource. This varies by resource type, and is a black box to Concourse; it is blindly passed to the resource at runtime.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Default []. A list of tags to determine which workers the checks will be performed on. You'll want to specify this if the source is internal to a worker's network, for example.
        :param pulumi.Input[str] type: The resource type implementing the resource.
        """
        if check_every is not None:
            pulumi.set(__self__, "check_every", check_every)
        if defaults is not None:
            pulumi.set(__self__, "defaults", defaults)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="checkEvery")
    def check_every(self) -> Optional[pulumi.Input[str]]:
        """
        Default 1m. The interval on which to check for new versions of the resource. Acceptable interval options are defined by the time.ParseDuration function. If set to never the resource will not be automatically checked. The resource can still be checked manually via the web UI, fly, or webhooks.
        """
        return pulumi.get(self, "check_every")

    @check_every.setter
    def check_every(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check_every", value)

    @property
    @pulumi.getter
    def defaults(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The default configuration for the resource type. This varies by resource type, and is a black box to Concourse; it is merged with (duplicate fields are overwritten by) resource.source and passed to the resource at runtime.
        """
        return pulumi.get(self, "defaults")

    @defaults.setter
    def defaults(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "defaults", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        TThe name of the resource type. This should be short and simple. This name will be referenced by pipeline.resources defined within the same pipeline, and task.image_resources used by tasks running in the pipeline.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Arbitrary config to pass when running the get to fetch the resource type's image.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        """
        Default false. If set to true, the resource's containers will be run with full capabilities, as determined by the worker backend the task runs on.
        """
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The configuration for the resource. This varies by resource type, and is a black box to Concourse; it is blindly passed to the resource at runtime.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Default []. A list of tags to determine which workers the checks will be performed on. You'll want to specify this if the source is internal to a worker's network, for example.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The resource type implementing the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ResourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 source: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 check_every: Optional[pulumi.Input[str]] = None,
                 public: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 webhook_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the resource. This should be short and simple. This name will be referenced by build plans of jobs in the pipeline.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] source: The configuration for the resource. This varies by resource type, and is a black box to Concourse; it is blindly passed to the resource at runtime.
        :param pulumi.Input[str] type: The resource type implementing the resource.
        :param pulumi.Input[str] check_every: Default 1m. The interval on which to check for new versions of the resource. Acceptable interval options are defined by the time.ParseDuration function. If set to never the resource will not be automatically checked. The resource can still be checked manually via the web UI, fly, or webhooks.
        :param pulumi.Input[bool] public: Default false. If set to true, the metadata for each version of the resource will be viewable by unauthenticated users (assuming the pipeline has been exposed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Default []. A list of tags to determine which workers the checks will be performed on. You'll want to specify this if the source is internal to a worker's network, for example.
        :param pulumi.Input[str] webhook_token: If specified, web hooks can be sent to trigger an immediate check of the resource, specifying this value as a primitive form of authentication via query params.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", type)
        if check_every is not None:
            pulumi.set(__self__, "check_every", check_every)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if webhook_token is not None:
            pulumi.set(__self__, "webhook_token", webhook_token)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the resource. This should be short and simple. This name will be referenced by build plans of jobs in the pipeline.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        The configuration for the resource. This varies by resource type, and is a black box to Concourse; it is blindly passed to the resource at runtime.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The resource type implementing the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="checkEvery")
    def check_every(self) -> Optional[pulumi.Input[str]]:
        """
        Default 1m. The interval on which to check for new versions of the resource. Acceptable interval options are defined by the time.ParseDuration function. If set to never the resource will not be automatically checked. The resource can still be checked manually via the web UI, fly, or webhooks.
        """
        return pulumi.get(self, "check_every")

    @check_every.setter
    def check_every(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check_every", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        Default false. If set to true, the metadata for each version of the resource will be viewable by unauthenticated users (assuming the pipeline has been exposed).
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Default []. A list of tags to determine which workers the checks will be performed on. You'll want to specify this if the source is internal to a worker's network, for example.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="webhookToken")
    def webhook_token(self) -> Optional[pulumi.Input[str]]:
        """
        If specified, web hooks can be sent to trigger an immediate check of the resource, specifying this value as a primitive form of authentication via query params.
        """
        return pulumi.get(self, "webhook_token")

    @webhook_token.setter
    def webhook_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_token", value)


@pulumi.input_type
class StepArgs:
    def __init__(__self__):
        pass


