# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AnonymousResourceArgs',
    'DisplayOptionsArgs',
    'GetStepArgs',
    'GroupArgs',
    'JobArgs',
    'ResourceTypeArgs',
    'ResourceArgs',
    'RunArgsArgs',
    'StepArgs',
    'TaskConfigArgs',
    'TaskStepArgs',
]

@pulumi.input_type
class AnonymousResourceArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", type)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "params", value)


@pulumi.input_type
class DisplayOptionsArgs:
    def __init__(__self__, *,
                 background_image: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_image: Allows users to specify a custom background image which is put at 30% opacity, grayscaled and blended into existing background. Must be an http, https, or relative URL.
        """
        if background_image is not None:
            pulumi.set(__self__, "background_image", background_image)

    @property
    @pulumi.getter(name="backgroundImage")
    def background_image(self) -> Optional[pulumi.Input[str]]:
        """
        Allows users to specify a custom background image which is put at 30% opacity, grayscaled and blended into existing background. Must be an http, https, or relative URL.
        """
        return pulumi.get(self, "background_image")

    @background_image.setter
    def background_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_image", value)


@pulumi.input_type
class GetStepArgs:
    def __init__(__self__, *,
                 get: pulumi.Input[str],
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 passed: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource: Optional[pulumi.Input[str]] = None,
                 trigger: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "get", get)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if passed is not None:
            pulumi.set(__self__, "passed", passed)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def get(self) -> pulumi.Input[str]:
        return pulumi.get(self, "get")

    @get.setter
    def get(self, value: pulumi.Input[str]):
        pulumi.set(self, "get", value)

    @property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def passed(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "passed")

    @passed.setter
    def passed(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "passed", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trigger", value)


@pulumi.input_type
class GroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 jobs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: A unique name for the group. This should be short and simple as it will be used as the tab name for navigation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jobs: A list of jobs that should appear in this group. A job may appear in multiple groups. Neighbours of jobs in the current group will also appear on the same page in order to give context of the location of the group in the pipeline. You may also use any valid glob to represent several jobs.
        """
        pulumi.set(__self__, "name", name)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A unique name for the group. This should be short and simple as it will be used as the tab name for navigation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of jobs that should appear in this group. A job may appear in multiple groups. Neighbours of jobs in the current group will also appear on the same page in order to give context of the location of the group in the pipeline. You may also use any valid glob to represent several jobs.
        """
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jobs", value)


@pulumi.input_type
class JobArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 plan: pulumi.Input[Sequence[pulumi.Input[Union['TaskStepArgs', 'GetStepArgs']]]],
                 ensure: Optional[pulumi.Input['StepArgs']] = None,
                 max_in_flight: Optional[pulumi.Input[float]] = None,
                 on_abort: Optional[pulumi.Input['StepArgs']] = None,
                 on_error: Optional[pulumi.Input['StepArgs']] = None,
                 on_failure: Optional[pulumi.Input['StepArgs']] = None,
                 on_success: Optional[pulumi.Input['StepArgs']] = None,
                 public: Optional[pulumi.Input[bool]] = None,
                 serial: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name of the job. This should be short; it will show up in URLs.
        :param pulumi.Input['StepArgs'] ensure: Step to execute regardless of whether the job succeeds, fails, errors, or aborts.
        :param pulumi.Input[float] max_in_flight: If set, specifies a maximum number of builds to run at a time. If serial or serial_groups are set, they take precedence and force this value to be 1.
        :param pulumi.Input['StepArgs'] on_abort: Step to execute when the job aborts.
        :param pulumi.Input['StepArgs'] on_error: Step to execute when the job errors.
        :param pulumi.Input['StepArgs'] on_failure: Step to execute when the job fails.
        :param pulumi.Input['StepArgs'] on_success: Step to execute when the job succeeds.
        :param pulumi.Input[bool] public: Default false. If set to true, the build log of this job will be viewable by unauthenticated users. Unauthenticated users will always be able to see the inputs, outputs, and build status history of a job. This is useful if you would like to expose your pipeline publicly without showing sensitive information in the build log.
        :param pulumi.Input[bool] serial: Default false. If set to true, builds will queue up and execute one-by-one, rather than executing in parallel.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "plan", plan)
        if ensure is not None:
            pulumi.set(__self__, "ensure", ensure)
        if max_in_flight is not None:
            pulumi.set(__self__, "max_in_flight", max_in_flight)
        if on_abort is not None:
            pulumi.set(__self__, "on_abort", on_abort)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the job. This should be short; it will show up in URLs.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def plan(self) -> pulumi.Input[Sequence[pulumi.Input[Union['TaskStepArgs', 'GetStepArgs']]]]:
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[Sequence[pulumi.Input[Union['TaskStepArgs', 'GetStepArgs']]]]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def ensure(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute regardless of whether the job succeeds, fails, errors, or aborts.
        """
        return pulumi.get(self, "ensure")

    @ensure.setter
    def ensure(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "ensure", value)

    @property
    @pulumi.getter(name="maxInFlight")
    def max_in_flight(self) -> Optional[pulumi.Input[float]]:
        """
        If set, specifies a maximum number of builds to run at a time. If serial or serial_groups are set, they take precedence and force this value to be 1.
        """
        return pulumi.get(self, "max_in_flight")

    @max_in_flight.setter
    def max_in_flight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_in_flight", value)

    @property
    @pulumi.getter(name="onAbort")
    def on_abort(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute when the job aborts.
        """
        return pulumi.get(self, "on_abort")

    @on_abort.setter
    def on_abort(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "on_abort", value)

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute when the job errors.
        """
        return pulumi.get(self, "on_error")

    @on_error.setter
    def on_error(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "on_error", value)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute when the job fails.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['StepArgs']]:
        """
        Step to execute when the job succeeds.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['StepArgs']]):
        pulumi.set(self, "on_success", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        Default false. If set to true, the build log of this job will be viewable by unauthenticated users. Unauthenticated users will always be able to see the inputs, outputs, and build status history of a job. This is useful if you would like to expose your pipeline publicly without showing sensitive information in the build log.
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[bool]]:
        """
        Default false. If set to true, builds will queue up and execute one-by-one, rather than executing in parallel.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serial", value)


@pulumi.input_type
class ResourceTypeArgs:
    def __init__(__self__, *,
                 check_every: Optional[pulumi.Input[str]] = None,
                 defaults: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] check_every: Default 1m. The interval on which to check for new versions of the resource. Acceptable interval options are defined by the time.ParseDuration function. If set to never the resource will not be automatically checked. The resource can still be checked manually via the web UI, fly, or webhooks.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] defaults: The default configuration for the resource type. This varies by resource type, and is a black box to Concourse; it is merged with (duplicate fields are overwritten by) resource.source and passed to the resource at runtime.
        :param pulumi.Input[str] name: TThe name of the resource type. This should be short and simple. This name will be referenced by pipeline.resources defined within the same pipeline, and task.image_resources used by tasks running in the pipeline.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] params: Arbitrary config to pass when running the get to fetch the resource type's image.
        :param pulumi.Input[bool] privileged: Default false. If set to true, the resource's containers will be run with full capabilities, as determined by the worker backend the task runs on.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] source: The configuration for the resource. This varies by resource type, and is a black box to Concourse; it is blindly passed to the resource at runtime.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Default []. A list of tags to determine which workers the checks will be performed on. You'll want to specify this if the source is internal to a worker's network, for example.
        :param pulumi.Input[str] type: The resource type implementing the resource.
        """
        if check_every is not None:
            pulumi.set(__self__, "check_every", check_every)
        if defaults is not None:
            pulumi.set(__self__, "defaults", defaults)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="checkEvery")
    def check_every(self) -> Optional[pulumi.Input[str]]:
        """
        Default 1m. The interval on which to check for new versions of the resource. Acceptable interval options are defined by the time.ParseDuration function. If set to never the resource will not be automatically checked. The resource can still be checked manually via the web UI, fly, or webhooks.
        """
        return pulumi.get(self, "check_every")

    @check_every.setter
    def check_every(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check_every", value)

    @property
    @pulumi.getter
    def defaults(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The default configuration for the resource type. This varies by resource type, and is a black box to Concourse; it is merged with (duplicate fields are overwritten by) resource.source and passed to the resource at runtime.
        """
        return pulumi.get(self, "defaults")

    @defaults.setter
    def defaults(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "defaults", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        TThe name of the resource type. This should be short and simple. This name will be referenced by pipeline.resources defined within the same pipeline, and task.image_resources used by tasks running in the pipeline.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Arbitrary config to pass when running the get to fetch the resource type's image.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        """
        Default false. If set to true, the resource's containers will be run with full capabilities, as determined by the worker backend the task runs on.
        """
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The configuration for the resource. This varies by resource type, and is a black box to Concourse; it is blindly passed to the resource at runtime.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Default []. A list of tags to determine which workers the checks will be performed on. You'll want to specify this if the source is internal to a worker's network, for example.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The resource type implementing the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ResourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 source: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 check_every: Optional[pulumi.Input[str]] = None,
                 public: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 webhook_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the resource. This should be short and simple. This name will be referenced by build plans of jobs in the pipeline.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] source: The configuration for the resource. This varies by resource type, and is a black box to Concourse; it is blindly passed to the resource at runtime.
        :param pulumi.Input[str] type: The resource type implementing the resource.
        :param pulumi.Input[str] check_every: Default 1m. The interval on which to check for new versions of the resource. Acceptable interval options are defined by the time.ParseDuration function. If set to never the resource will not be automatically checked. The resource can still be checked manually via the web UI, fly, or webhooks.
        :param pulumi.Input[bool] public: Default false. If set to true, the metadata for each version of the resource will be viewable by unauthenticated users (assuming the pipeline has been exposed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Default []. A list of tags to determine which workers the checks will be performed on. You'll want to specify this if the source is internal to a worker's network, for example.
        :param pulumi.Input[str] webhook_token: If specified, web hooks can be sent to trigger an immediate check of the resource, specifying this value as a primitive form of authentication via query params.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", type)
        if check_every is not None:
            pulumi.set(__self__, "check_every", check_every)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if webhook_token is not None:
            pulumi.set(__self__, "webhook_token", webhook_token)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the resource. This should be short and simple. This name will be referenced by build plans of jobs in the pipeline.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        The configuration for the resource. This varies by resource type, and is a black box to Concourse; it is blindly passed to the resource at runtime.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The resource type implementing the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="checkEvery")
    def check_every(self) -> Optional[pulumi.Input[str]]:
        """
        Default 1m. The interval on which to check for new versions of the resource. Acceptable interval options are defined by the time.ParseDuration function. If set to never the resource will not be automatically checked. The resource can still be checked manually via the web UI, fly, or webhooks.
        """
        return pulumi.get(self, "check_every")

    @check_every.setter
    def check_every(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check_every", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        Default false. If set to true, the metadata for each version of the resource will be viewable by unauthenticated users (assuming the pipeline has been exposed).
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Default []. A list of tags to determine which workers the checks will be performed on. You'll want to specify this if the source is internal to a worker's network, for example.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="webhookToken")
    def webhook_token(self) -> Optional[pulumi.Input[str]]:
        """
        If specified, web hooks can be sent to trigger an immediate check of the resource, specifying this value as a primitive form of authentication via query params.
        """
        return pulumi.get(self, "webhook_token")

    @webhook_token.setter
    def webhook_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_token", value)


@pulumi.input_type
class RunArgsArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dir: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "path", path)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def dir(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dir")

    @dir.setter
    def dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dir", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class StepArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class TaskConfigArgs:
    def __init__(__self__, *,
                 image_resource: pulumi.Input['AnonymousResourceArgs'],
                 platform: pulumi.Input[str],
                 run: pulumi.Input['RunArgsArgs']):
        pulumi.set(__self__, "image_resource", image_resource)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "run", run)

    @property
    @pulumi.getter
    def image_resource(self) -> pulumi.Input['AnonymousResourceArgs']:
        return pulumi.get(self, "image_resource")

    @image_resource.setter
    def image_resource(self, value: pulumi.Input['AnonymousResourceArgs']):
        pulumi.set(self, "image_resource", value)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def run(self) -> pulumi.Input['RunArgsArgs']:
        return pulumi.get(self, "run")

    @run.setter
    def run(self, value: pulumi.Input['RunArgsArgs']):
        pulumi.set(self, "run", value)


@pulumi.input_type
class TaskStepArgs:
    def __init__(__self__, *,
                 task: pulumi.Input[str],
                 config: Optional[pulumi.Input['TaskConfigArgs']] = None,
                 image: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "task", task)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def task(self) -> pulumi.Input[str]:
        return pulumi.get(self, "task")

    @task.setter
    def task(self, value: pulumi.Input[str]):
        pulumi.set(self, "task", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['TaskConfigArgs']]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['TaskConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


